import 'dart:async';

import 'package:build/build.dart' hide log;
import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:dynamite/src/builder/client.dart';
import 'package:dynamite/src/builder/generate_ofs.dart';
import 'package:dynamite/src/builder/generate_schemas.dart';
import 'package:dynamite/src/builder/serializer.dart';
import 'package:dynamite/src/builder/state.dart';
import 'package:dynamite/src/helpers/docs.dart';
import 'package:dynamite/src/helpers/logger.dart';
import 'package:dynamite/src/helpers/version_checker.dart';
import 'package:dynamite/src/models/config.dart';
import 'package:version/version.dart';

class OpenAPIBuilder implements Builder {
  OpenAPIBuilder(
    BuilderOptions options,
  ) : buildConfig = DynamiteConfig.fromJson(options.config);

  @override
  final buildExtensions = const {
    '.openapi.json': ['.openapi.dart'],
    '.openapi.yaml': ['.openapi.dart'],
  };

  /// The minimum openapi version supported by this builder.
  static final Version minSupportedVersion = Version(3, 0, 0);

  /// The maximum openapi version supported by this builder.
  static final Version maxSupportedVersion = minSupportedVersion.incrementMajor();

  /// The configuration for this builder.
  final DynamiteConfig buildConfig;

  @override
  Future<void> build(BuildStep buildStep) async {
    final result = await helperVersionCheck(buildStep);

    if (result.messages.isNotEmpty) {
      if (result.hasFatal) {
        log.severe(result.messages);
        return;
      } else {
        log.info(result.messages);
      }
    }

    final state = State(buildConfig, buildStep);

    try {
      await state.init();

      final version = Version.parse(state.spec.version);
      if (version < minSupportedVersion || version > maxSupportedVersion) {
        throw Exception('Only OpenAPI between $minSupportedVersion and $maxSupportedVersion are supported.');
      }

      final output = Library((b) {
        final analyzerIgnores = state.buildConfig.analyzerIgnores;
        if (analyzerIgnores != null) {
          b.ignoreForFile.addAll(analyzerIgnores);
        }

        final comment = state.spec.info.license?.formattedDescription();
        if (comment != null) {
          b.comments.add(comment);
        }

        b
          ..generatedByComment = 'OpenAPI client generated by Dynamite. Do not manually edit this file.'
          ..docs.addAll(
            escapeDescription(state.spec.info.formattedDescription()),
          )
          ..directives.addAll([
            Directive.import('dart:convert'),
            Directive.import('dart:typed_data'),
            Directive.import('package:built_collection/built_collection.dart'),
            Directive.import('package:built_value/json_object.dart'),
            Directive.import('package:dynamite_runtime/models.dart'),
          ])
          ..body.addAll(generateClients(state.spec, state))
          ..body.addAll(generateSchemas(state.spec, state))
          ..body.addAll(buildOfsExtensions(state))
          ..body.addAll(buildSerializer(state));

        if (state.buildConfig.experimental) {
          b.annotations.add(
            refer('experimental', 'package:meta/meta.dart'),
          );
        }
      });

      var outputString = output.accept(state.emitter).toString();

      final coverageIgnores = state.buildConfig.coverageIgnores;
      if (coverageIgnores != null) {
        for (final ignore in coverageIgnores) {
          final pattern = RegExp(ignore);

          final before = outputString;
          outputString = before.replaceAllMapped(
            pattern,
            (match) => '  // coverage:ignore-start\n${match.group(0)}\n  // coverage:ignore-end',
          );
          if (outputString == before) {
            log.warning(
              'Coverage ignore pattern $ignore did not match anything',
            );
          }
        }
      }

      final formatter = DartFormatter(pageWidth: buildConfig.pageWidth);
      unawaited(
        buildStep.writeAsString(
          state.outputId,
          formatter.format(outputString),
        ),
      );
    } catch (error, stackTrace) {
      log.severe(
        'Issue generating the library for $state.inputId',
        error,
        stackTrace,
      );

      rethrow;
    }
  }
}
